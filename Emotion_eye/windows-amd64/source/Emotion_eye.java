/* autogenerated by Processing revision 1284 on 2022-08-08 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import com.hamoid.*;
import java.io.File;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class Emotion_eye extends PApplet {


float t1=0;

Eye e1, e2, e3;
JSONObject json;
int bgColorTL, bgColorTR, bgColorBR, bgColorBL, bgColorT,bgColorTt;
String emotion_now, emotion_before;
boolean change = false;
float [] thetaMax;
ParticleSystem ps;
ParticleSystem2 ps2;
//float soundDuration = 10.03;
int index=1;

//variables for mouth

float theta = 0.0f;
//neutral:
int w; 
float[] yvalues; 
float dx; 
int xspacing = 5; 
//disgust mouth:
int dis_xspacing = 1;   
int maxwaves = 10;  
float[] amplitude_dis = new float[maxwaves];  
float[] dis_dx = new float[maxwaves];       
float[] dis_yvalues;     

//surprise, fear mouth:
PVector [] pos;
float [] radiusF, radiusFIncre;



 public void setup() {
  /* size commented out by preprocessor */;
  /* smooth commented out by preprocessor */;
  noStroke();
  bgColorTL = bgColorTR = bgColorBR = bgColorBL = bgColorT = bgColorTt = color(0xFFE7C5CC); //neutral background
   
  e1 = new Eye(270, 280, 170);
  e2 = new Eye(470, 290, 170);
 
  ps = new ParticleSystem(new PVector(3*width/4-70,height/2-25));
  ps2 = new ParticleSystem2(new PVector(width/3-30,height/2-25));
  
    //fear, surprise mouth initiation
  pos = new PVector[40];
  radiusF = new float[40];
  radiusFIncre = new float[40];
  for(int i=0; i<pos.length; i++){
    pos[i] = new PVector();
    radiusF[i] = random(100);
    radiusFIncre[i] = random(.005f, .015f);
  }
  //videoExport = new VideoExport(this, "myVideo.mp4");
  //videoExport.setFrameRate(30);  
  //videoExport.startMovie();
}

 public void draw() {  
  background();
  String path="C:\\Users\\19051\\Desktop\\Capstoneproject\\json\\result"+str(index)+"json";
  String get_emo="";
  File f=new File(path);
  if(!f.exists()){
      print(str(index)+"file not exist");
     //videoExport.endMovie();
      exit();
  }else{
    json=loadJSONObject(path);
    get_emo=json.getString("emotion");
    }
  print(get_emo+"\n");
  index+=1;
  //Begin to start the video and end the video
  //if(mousePressed){
  //  if(mouseButton == LEFT){
  //    videoExport.startMovie();
  //  }

  //for(int i=0;i<1000; i++){  //iteration
  //    emotion_before = emotion_now;  //The animation will display emotion_before
      emotion_before = json.getString("emotion");//情绪的参数
     
      if (emotion_now == emotion_before){  //if not change, continue
        change = false;
        //continue;
      }
  
   // save the frame
  //}
  
  emotion(emotion_before);
  e1.update(cos(60), sin(60));//左眼球的参数(cos(角度),sin(角度))
  e2.update(cos(60),sin(60));//右眼球的参数
  e1.display1(emotion_before);
  e2.display2(emotion_before);
  saveFrame(str(index)+".jpg");
}

//background colors
 public void background(){
  bgColorTL = lerpColor(bgColorTL, bgColorT, .25f);
  bgColorTR = lerpColor(bgColorTR, bgColorT, .125f);
  bgColorBR = lerpColor(bgColorBR, bgColorT, .625f);
  bgColorBL = lerpColor(bgColorBL, bgColorT, .3125f);

  noStroke();
  beginShape(QUADS);
  fill(bgColorTL);
  vertex(0, 0);//TL
  fill(bgColorTR);
  vertex(width, 0);//TR
  fill(bgColorBR);
  vertex(width, height);//BR
  fill(bgColorBL);
  vertex(0, height);//BL
  endShape();
}

//Different emotions
 public void emotion (String type){
  if (type "neutral"){
    bgColorT = 0xFFE7C5CC;
    neutral_mouth(0);
  }
  if (type == "happy"){
    bgColorT = 0xFFF6C762;
    fill(225,136,57);
    pushMatrix();
    translate(width*0.5f, height*0.5f);
    rotate(frameCount / 400.0f);
    star(0, 0, 220, 280, 20); 
    popMatrix();
    happy_mouth(80, 300, 310, 320, 270, 325);
    //float open_cred(0~100), float left_mouth_corner_y, float right_mouth_corner_y, float mid_y,float lip_top_y, float lip_bottom_y
  }
  if (type == "disgust"){
    bgColorT = 0xFF549C78;
    disgust_background();
    noStroke();
    fill(124,120,14);
    pushMatrix();
    translate(width*0.5f, height*0.5f);
    rotate(frameCount / 400.0f);
    flower(0, 0, 260, 280, 10); 
    popMatrix();
    disgust_mouth(100);//mouth open_cred(0~100)
  }
  if (type == "anger"){
    bgColorT = 0xFFDA4D5B;
    fill(180,20,0);
    anger_background();
    pushMatrix();
    translate(width*0.5f, height*0.5f);
    rotate(frameCount / 400.0f);
    star(0, 0, 200, 280, 35); 
    popMatrix();
    anger_mouth(80);//mouth open_cred(0~100)
  }
  if (type == "fear"){
    bgColorT = 0xFF9B1EA3;
    fear_background();
    fill(110,0,160);
    pushMatrix();
    translate(width*0.5f, height*0.5f);
    rotate(frameCount / 400.0f);
    flower(0, 0, 230, 270, 17); 
    popMatrix();
    fear_mouth(80);//mouth open_cred(0~100)
  }
  if (type == "sadness"){
    bgColorT = 0xFF3A76C8;
    fill(14,65,201);
    pushMatrix();
    translate(width*0.5f, height*0.5f);
    rotate(frameCount / 400.0f);
    flower(0, 0, 230, 280, 7); 
    popMatrix();
     sad_mouth(80, 300, 320, 290, 270, 325);
    //float mouth open_cred(0~100), float left_mouth_corner_y, float right_mouth_corner_y, float mid_y,float lip_top_y, float lip_bottom_y
    
    
  }
  if (type == "Surprise"){
    bgColorT = 0xFFEE8833;
    surprise_mouth(80);//mouth open_cred(0~100)
    fill(255,245,46);
    pushMatrix();
    translate(width*0.5f, height*0.5f);
    rotate(frameCount / 400.0f);
    star2(0, 0, 210, 280, 65); 
    popMatrix();
  }
}

//Shape:
//(1) Happy
 public void star(float x, float y, float radius1, float radius2, int npoints) {
  float angle = TWO_PI / npoints;
  float halfAngle = angle/2.0f;
  beginShape();
  for (float a = 0; a < TWO_PI; a += angle) {
    float sx = x + cos(a) * radius2;
    float sy = y + sin(a) * radius2;
    vertex(sx, sy);
    sx = x + cos(a+halfAngle) * radius1;
    sy = y + sin(a+halfAngle) * radius1;
    vertex(sx, sy);
  }
  endShape(CLOSE);
}

 public void star2(float x, float y, float radius1, float radius2, int npoints) {
  float angle = TWO_PI / npoints;
  float halfAngle = angle/2.0f;
  beginShape();
  for (float a = 0; a < TWO_PI; a += angle) {
    float sx = x + cos(a) * radius2;
    float sy = y + sin(a) * radius2;
    vertex(sx, sy);
    sx = lerp(x + cos(a+halfAngle-angle) * radius1,x + cos(a+halfAngle) * radius1,0.0125f);
    sy = lerp(y + sin(a+halfAngle-angle) * radius1,y + sin(a+halfAngle) * radius1,0.0125f);
    vertex(sx, sy);
  }
  endShape(CLOSE);
}

 public void flower(float x, float y, float radius1, float radius2, int npoints) {
  float angle = TWO_PI / npoints;
  float halfAngle = angle/2.0f;
  beginShape();
  for (float a = 0; a < TWO_PI+1; a += angle) {
    float sx = x + cos(a) * radius2;
    float sy = y + sin(a) * radius2;
    curveVertex(sx, sy);
    sx = lerp(x + cos(a+halfAngle-angle) * radius1,x + cos(a+halfAngle) * radius1,0.825f);
    sy = lerp(y + sin(a+halfAngle-angle) * radius1,y + sin(a+halfAngle) * radius1,0.825f);
    curveVertex(sx, sy);
  }
  endShape(CLOSE);
}   
 public void fear_background(){
  
  int amt = 10000, cols = 100, rows=100;
  float cellSize;
  
  cellSize = width*1.0f/cols; 
  bgColorT = color(85,23,89);
  
  for(int i = 0;i<amt;i++){
    int col= i%cols;
    int row= i/cols;
    float x = map(col, 0, cols-2, cellSize*.5f, width-cellSize*.5f);
    float y = map(row, 0, rows-2, cellSize*.5f, height-cellSize*.5f);
    float rtt = map(noise(col*.05f, row*.05f, 0.01f), 0,1,-PI*1.5f, PI*1.5f);
    
    pushMatrix();
    translate(x,y);
    rotate(rtt+frameCount*0.1f);
    strokeWeight(60);
    stroke(156,31,164,40);
    line(0, 0, 20, 0);
    popMatrix();
  }
}

 public void anger_background(){
  int amt = 10000, cols = 100, rows=100;
  float cellSize;
  
  cellSize = width*1.0f/cols; 
  bgColorT = color(120);
  
  for(int i = 0;i<amt;i++){
    int col= i%cols;
    int row= i/cols;
    float x = map(col, 0, cols-2, cellSize*.5f, width-cellSize*.5f);
    float y = map(row, 0, rows-2, cellSize*.5f, height-cellSize*.5f);
    float rtt = map(noise(col*.05f, row*.05f, 0.01f), 0,1,-PI*1.5f, PI*1.5f);
    
    pushMatrix();
    translate(x,y);
    rotate(rtt+frameCount*0.1f);
    strokeWeight(60);
    stroke(255,141,133,40);
    line(0, 0, 20, 0);
    popMatrix();
  }
}

 public void disgust_background(){
  int cols = 10, rows = 10;
  int amt = cols*rows;
  float cellSize;
  
  noFill();
  stroke(0);
  strokeWeight(5);
  bgColorT = 0xFF549C78;
  cellSize = width*1.0f/cols;
  thetaMax = new float[amt];
  
  for(int i=0; i<amt; i++){
    int col = i%cols;
    int row = i/cols;
    float ctrX = map(col, 0, cols-1, cellSize*.5f, width-cellSize*.5f);
    float ctrY = map(row, 0, rows-1, cellSize*.5f, height-cellSize*.5f);
    drawSpiral(120, i, ctrX, ctrY, PI*.25f*i, cellSize*.5f);
  }
}

 public void drawSpiral(int res, int idx, float ctrX, float ctrY, float thetaOfst, float rMax){
  float d = dist(cos(60), sin(60), ctrX, ctrY); //前两个的角度是眼球角度
  d = constrain(d, 0, width*.7f);
  thetaMax[idx] = lerp(thetaMax[idx], map(d, 0, width*.5f, TWO_PI*4, 0), .0625f);
  
  beginShape();
  for(int i=0; i<res; i++){
    float theta = map(i, 0, res-1, 0, thetaMax[idx]*6)+thetaOfst;
    float r = map(i, 0, res-1, rMax, 0);
    float x = cos(theta)*r+ctrX;
    float y = sin(theta)*r+ctrY;
    vertex(x, y);
  }
  endShape();
}
class Eye {
  int x, y;
  int size;
  float angle = 0.0f;
  PVector v1, v2, v3, v4, v5, v6;
  
  Eye(int tx, int ty, int ts) {
    x = tx;
    y = ty;
    size = ts;
 }
 
 /* Actual Parameters:

  void update(float [] right_corner, float [] left_corner,
  float [] top, float [] bottom, float [] pupil,){
    //map the actual pupil position to the cartoon eye
    x_pupil = map(pupil[0],left_corner[0],right_corner[0], x-size+size/1.4, x+size-size/1.4);
    y_pupil = map(pupil[1],top[1], bottom[1], y-size+size/1.4, y+size-size/1.4);
  }
  
  //neutral eye
  void display(){
    fill(255);
    ellipse(x, y, size, size);
    fill(0);
    ellipse(x_pupil, y_pupil, size/1.4, size/1.4);
  }
*/


   public void update(float mx, float my) {
    angle = atan2(my-y, mx-x);
  }
  
//left eye:
   public void display1(String type){
    if (type == "neutral"){
      pushMatrix();
      translate(x, y);
      fill(255);
      ellipse(0, 0, size, size);
      rotate(angle);
      fill(0);
      ellipse(size/8, 0, size/1.4f, size/1.4f);
      popMatrix();
    }
    if (type == "happy"){
      pushMatrix();
      translate(x, y);
      fill(255);
      //ellipse(0, 0, size, size*0.8);
      
      float r = size/2.0f;
      v1 = new PVector(0, -r);
      v2 = new PVector(r, 0);
      v3 = new PVector(0.6f*r, 2.5f/4*r);
      v4 = new PVector(0, 0.57f*r);
      v5 = new PVector(-0.6f*r, 2.5f/4*r);
      v6 = new PVector(-r, 0);
      beginShape();
      vertex(v1.x, v1.y);
      bezierVertex(v1.x+40, v1.y, v2.x-10, v2.y-50, v2.x, v2.y);
      bezierVertex(v2.x+10, v2.y+50, v3.x+15, v3.y-5, v3.x, v3.y);
      bezierVertex(v3.x-15, v3.y, v4.x+40, v4.y, v4.x, v4.y);
      bezierVertex(v4.x-40, v4.y, v5.x+20, v5.y, v5.x, v5.y);
      bezierVertex(v5.x-20, v5.y-5, v6.x-10, v6.y+50, v6.x, v6.y);
      bezierVertex(v6.x+10, v6.y-50, v1.x-40, v1.y, v1.x, v1.y);
      endShape();
    
      rotate(angle);
      fill(214,172,2);
      ellipse(size/8, 0, size/1.4f, size/1.4f);
      popMatrix();
    }
    if (type == "disgust"){
      pushMatrix();
      translate(x, y);
      fill(255);
      ellipse(0, 0, size, size*1.3f);
      rotate(angle);
      fill(54,129,12);
      ellipse(size/8, 0, size/1.4f, size/1.4f);
      popMatrix();
    }
    if (type == "anger"){
      pushMatrix();
      translate(x, y);
      fill(255);
      //ellipse(0, 0, size, size*0.8);
      beginShape();
      float r = size/2;
      v1 = new PVector(-0.707f*r*1.1f, -0.707f*r*1.1f);
      v2 = new PVector(0, -0.707f*r*1.27f);
      v3 = new PVector(2/2.236f*r*1.1f, -1/2.236f*r*1.1f);
      v4 = new PVector(0.6f*r*1.1f, 2.5f/4*r*1.1f);
      v5 = new PVector(-0.707f*2/3*r*1.1f, 0.707f*2/3*r*1.1f);
      vertex(v1.x, v1.y);
      bezierVertex(v1.x+10, v1.y-10, v2.x-30, v2.y-5, v2.x, v2.y);
      bezierVertex(v2.x+30, v2.y+5, v3.x-10, v3.y-20, v3.x, v3.y);
      bezierVertex(v3.x+10, v3.y+20, v4.x+20, v4.y-20, v4.x, v4.y);
      bezierVertex(v4.x-20, v4.y+20, v5.x+50, v5.y+50, v5.x, v5.y);
      bezierVertex(v5.x-50, v5.y-50, v1.x-10, v1.y+10, v1.x, v1.y);
      endShape();
    
      rotate(angle);
      fill(147,20,0);
      ellipse(size/8, 0, size/1.4f, size/1.4f);
      popMatrix();
    }
    if (type == "fear"){
      pushMatrix();
      translate(x, y);
      fill(255);
      ellipse(0, 0, size, size*1.3f);
      rotate(angle);
      fill(89,5,95);
      ellipse(size/8, 0, size/1.4f, size/1.4f);
      popMatrix();
    }
    if (type == "sadness"){
      pushMatrix();
      translate(x, y);
      fill(255);
      //ellipse(0, 0, size, size*0.8);
      
      beginShape();
      float r = size/2;
      v1 = new PVector(-0.707f*r*1.1f, 0.707f*r*1.1f);
      v2 = new PVector(0, 0.707f*r*1.27f);
      v3 = new PVector(2/2.236f*r*1.1f, 1/2.236f*r*1.1f);
      v4 = new PVector(0.6f*r*1.1f, -2.5f/4*r*1.3f);
      v5 = new PVector(-0.707f*2/3*r*1.1f, -0.707f*2/3*r*1.1f);
      vertex(v1.x, v1.y);
      bezierVertex(v1.x+10, v1.y+10, v2.x-30, v2.y+5, v2.x, v2.y);
      bezierVertex(v2.x+30, v2.y-5, v3.x-10, v3.y+20, v3.x, v3.y);
      bezierVertex(v3.x+10, v3.y-20, v4.x+20, v4.y+20, v4.x, v4.y);
      bezierVertex(v4.x-20, v4.y-20, v5.x+50, v5.y-50, v5.x, v5.y);
      bezierVertex(v5.x-50, v5.y+50, v1.x-10, v1.y-10, v1.x, v1.y);
      endShape();
      
      rotate(angle);
      fill(5,7,95);
      ellipse(size/8, 0, size/1.4f, size/1.4f);
      popMatrix();
    }
    if (type == "surprise"){
      pushMatrix();
      translate(x, y);
      fill(255);
      ellipse(0, 0, size, size*1.3f);
      rotate(angle);
      fill(209,202,78);
      ellipse(size/8, 0, size/1.4f, size/1.4f);
      popMatrix();
    }  
  }
  
//right eye:
   public void display2(String type){
    if (type == "neutral"){
      pushMatrix();
      translate(x, y);
      fill(255);
      ellipse(0, 0, size, size);
      rotate(angle);
      fill(0);
      ellipse(size/8, 0, size/1.4f, size/1.4f);
      popMatrix();
    }
    if (type == "happy"){
      pushMatrix();
      translate(x, y);
      fill(255);
      //ellipse(0, 0, size, size*0.8);
      
      float r = size/2.0f;
      v1 = new PVector(0, -r);
      v2 = new PVector(r, 0);
      v3 = new PVector(0.6f*r, 2.5f/4*r);
      v4 = new PVector(0, 0.57f*r);
      v5 = new PVector(-0.6f*r, 2.5f/4*r);
      v6 = new PVector(-r, 0);
      beginShape();
      vertex(v1.x, v1.y);
      bezierVertex(v1.x+40, v1.y, v2.x-10, v2.y-50, v2.x, v2.y);
      bezierVertex(v2.x+10, v2.y+50, v3.x+15, v3.y-5, v3.x, v3.y);
      bezierVertex(v3.x-15, v3.y, v4.x+40, v4.y, v4.x, v4.y);
      bezierVertex(v4.x-40, v4.y, v5.x+20, v5.y, v5.x, v5.y);
      bezierVertex(v5.x-20, v5.y-5, v6.x-10, v6.y+50, v6.x, v6.y);
      bezierVertex(v6.x+10, v6.y-50, v1.x-40, v1.y, v1.x, v1.y);
      endShape();
    
      rotate(angle);
      fill(214,172,2);
      ellipse(size/8, 0, size/1.4f, size/1.4f);
      popMatrix();
    }
    if (type == "disgust"){
      pushMatrix();
      translate(x, y);
      rotate(45);
      fill(255);
      ellipse(0, 0, size, size);
      rotate(angle);
      fill(54,129,12);
      ellipse(size/8, 0, size/1.4f, size/1.4f);
      popMatrix();
    }
    if (type == "anger"){
      pushMatrix();
      translate(x, y);
      fill(255);
      //ellipse(0, 0, size, size*0.8);
      beginShape();
      float r = size/2;
      v1 = new PVector(0.707f*r*1.1f, -0.707f*r*1.1f);
      v2 = new PVector(0, -0.707f*r*1.27f);
      v3 = new PVector(-2/2.236f*r*1.1f, -1/2.236f*r*1.1f);
      v4 = new PVector(-0.6f*r*1.1f, 2.5f/4*r*1.1f);
      v5 = new PVector(0.707f*2/3*r*1.1f, 0.707f*2/3*r*1.1f);
      vertex(v1.x, v1.y);
      bezierVertex(v1.x-10, v1.y-10, v2.x+30, v2.y-5, v2.x, v2.y);
      bezierVertex(v2.x-30, v2.y+5, v3.x+10, v3.y-20, v3.x, v3.y);
      bezierVertex(v3.x-10, v3.y+20, v4.x-20, v4.y-20, v4.x, v4.y);
      bezierVertex(v4.x+20, v4.y+20, v5.x-50, v5.y+50, v5.x, v5.y);
      bezierVertex(v5.x+50, v5.y-50, v1.x+10, v1.y+10, v1.x, v1.y);
      endShape();
    
      rotate(angle);
      fill(147,20,0);
      ellipse(size/8, 0, size/1.4f, size/1.4f);
      popMatrix();
    }
    if (type == "fear"){
      pushMatrix();
      translate(x, y);
      fill(255);
      ellipse(0, 0, size, size*1.3f);
      rotate(angle);
      fill(89,5,95);
      ellipse(size/8, 0, size/1.4f, size/1.4f);
      popMatrix();
    }
    if (type == "sadness"){
      pushMatrix();
      translate(x, y);
      fill(255);
      //ellipse(0, 0, size, size*0.8);
      beginShape();
      float r = size/2;
      v1 = new PVector(0.707f*r*1.1f, 0.707f*r*1.1f);
      v2 = new PVector(0, 0.707f*r*1.27f);
      v3 = new PVector(-2/2.236f*r*1.1f, 1/2.236f*r*1.1f);
      v4 = new PVector(-0.6f*r*1.1f, -2.5f/4*r*1.3f);
      v5 = new PVector(0.707f*2/3*r*1.1f, -0.707f*2/3*r*1.1f);
      vertex(v1.x, v1.y);
      bezierVertex(v1.x-10, v1.y+10, v2.x+30, v2.y+5, v2.x, v2.y);
      bezierVertex(v2.x-30, v2.y-5, v3.x+10, v3.y+20, v3.x, v3.y);
      bezierVertex(v3.x-10, v3.y-20, v4.x-20, v4.y+20, v4.x, v4.y);
      bezierVertex(v4.x+20, v4.y-20, v5.x-50, v5.y-50, v5.x, v5.y);
      bezierVertex(v5.x+50, v5.y+50, v1.x+10, v1.y-10, v1.x, v1.y);
      endShape();
      
      rotate(angle);
      fill(5,7,95);
      ellipse(size/8, 0, size/1.4f, size/1.4f);
      popMatrix();
      ps.addParticle();
      ps2.addParticle2();
      ps.run();
      ps2.run2();
    }
    if (type == "surprise"){
      pushMatrix();
      translate(x, y);
      fill(255);
      ellipse(0, 0, size, size*1.3f);
      rotate(angle);
      fill(209,202,78);
      ellipse(size/8, 0, size/1.4f, size/1.4f);
      popMatrix();
    }  
  }
}
//neutral mouth
 public void neutral_mouth(float open_cred){
  //Sine Wave by Daniel Shiffman. 
  float period = 500.0f;
  w = width+16;
  dx = (TWO_PI / period) * xspacing;
  yvalues = new float[w/xspacing];
  neutral_calcWave(open_cred);
  neutral_renderWave();
}

 public void neutral_calcWave(float open_cred) {
  theta += 0.02f;
  float x = theta;
  float amplitude = map(open_cred, 0, 100, 25.0f, 50); //amplitude change with the opening of the mouth
  for (int i = 0; i < yvalues.length; i++) {
    yvalues[i] = sin(x)*amplitude;
    x+=dx;
  }
}
 public void neutral_renderWave() {
  pushMatrix();
  noStroke();
  fill(255);
  translate(0, 150);
  for (int x = 0; x < yvalues.length; x++) {
    ellipse(x*xspacing, height/2+yvalues[x], 16, 16);
  }
  popMatrix();
}

//disgust mouth:
 public void disgust_mouth(float open_cred){
  randomSeed(10);
  int w;  
  w = width + 16;
  dis_yvalues = new float[w/dis_xspacing];
  maxwaves = round(map(open_cred, 0, 100, 2, 10));//map the opening of the mouth to the amplitudud of the waves
  theta += 0.2f;

  for (int i = 0; i < maxwaves; i++) {
    amplitude_dis[i] = random(10,30);
    float period = random(100,150); 
    dis_dx[i] = (TWO_PI / period) * dis_xspacing;
  }

  for (int i = 0; i < dis_yvalues.length; i++) {
    dis_yvalues[i] = 0;
  }
  for (int j = 0; j < maxwaves; j++) {
    float x = theta;
    for (int i = 0; i < dis_yvalues.length; i++) {
      if (j % 2 == 0)  dis_yvalues[i] += sin(x)*amplitude_dis[j];
      else dis_yvalues[i] += cos(x)*amplitude_dis[j];
      x+=dis_dx[j];
    }
  }
  disgust_renderWave();
}

 public void disgust_renderWave() {
  pushMatrix();
  noStroke();
  fill(54,129,12);
  translate(0, 100, 2);
  ellipseMode(CENTER);
  for (int x = 0; x < dis_yvalues.length; x++) {
    ellipse(x*dis_xspacing,height/2+dis_yvalues[x],16,16);
  }
  popMatrix();
}

//Angery Mouth:
 public void anger_mouth(float open_cred){
  randomSeed(10);
  int w;  
  w = width + 16;
  dis_yvalues = new float[w/dis_xspacing];
  maxwaves = round(map(open_cred, 0, 100, 2, 10));//map the opening of the mouth to the amplitudud of the waves
  theta += 0.2f;

  for (int i = 0; i < maxwaves; i++) {
    amplitude_dis[i] = random(10,30);
    float period = random(100,150); 
    dis_dx[i] = (TWO_PI / period) * dis_xspacing;
  }

  for (int i = 0; i < dis_yvalues.length; i++) {
    dis_yvalues[i] = 0;
  }
  for (int j = 0; j < maxwaves; j++) {
    float x = theta;
    for (int i = 0; i < dis_yvalues.length; i++) {
      if (j % 2 == 0)  dis_yvalues[i] += sin(x)*amplitude_dis[j];
      else dis_yvalues[i] += cos(x)*amplitude_dis[j];
      x+=dis_dx[j];
    }
  }
  anger_renderWave();
}

 public void anger_renderWave() {
  pushMatrix();
  noStroke();
  fill(253,91,79);
  translate(0, 100, 2);
  ellipseMode(CENTER);
  for (int x = 0; x < dis_yvalues.length; x++) {
    ellipse(x*dis_xspacing,height/2+dis_yvalues[x],16,16);
  }
  popMatrix();
}

//Sad mouth:
 public void sad_mouth(float open_cred, float left_mouth_corner_y, float right_mouth_corner_y, float mid_y,
               float lip_top_y, float lip_bottom_y){
  pushMatrix();
  fill(156,192,248);
  noStroke();
  translate(0, 180, 2);
  float leftY = map(left_mouth_corner_y, lip_top_y-10, lip_bottom_y+10, 300, 400);
  float rightY = map(right_mouth_corner_y, lip_top_y-10, lip_bottom_y+10, 300, 400);
  float midY = map(mid_y, lip_top_y-10, lip_bottom_y+10, 300, 400);
  float open = map(open_cred, 0, 100, 2, 40);
  
  beginShape();
  strokeWeight(2);
  curveVertex(0, leftY);
  curveVertex(0, leftY);
  curveVertex(350, midY);
  curveVertex(800, rightY);
  curveVertex(800, rightY-10);
  curveVertex(350, midY-open);
  curveVertex(0, leftY-14);
  curveVertex(0, leftY-14);
  endShape();
  popMatrix();
}

//Happy Mouth:
 public void happy_mouth(float open_cred, float left_mouth_corner_y, float right_mouth_corner_y, float mid_y,
               float lip_top_y, float lip_bottom_y){
  pushMatrix();
  fill(245,225,164);
  noStroke();
  translate(0, 140, 2);
  float leftY = map(left_mouth_corner_y, lip_top_y-10, lip_bottom_y+10, 300, 400);
  float rightY = map(right_mouth_corner_y, lip_top_y-10, lip_bottom_y+10, 300, 400);
  float midY = map(mid_y, lip_top_y-10, lip_bottom_y+10, 300, 400);
  float open = map(open_cred, 0, 100, 2, 40);
  
  beginShape();
  strokeWeight(2);
  curveVertex(0, leftY+18);
  curveVertex(0, leftY+18);
  curveVertex(350, midY+open);
  curveVertex(800, rightY+8);
  curveVertex(800, rightY);
  curveVertex(350, midY);
  curveVertex(0, leftY);
  curveVertex(0, leftY);
  endShape();
  popMatrix();
}

//Surprise_Mouth:
 public void surprise_mouth(float open_cred){
  for(int i=0; i<pos.length; i++){
    radiusF[i] += radiusFIncre[i];
    float theta = map(i, 0, pos.length, 0, TWO_PI);
    float r = map(noise(radiusF[i]*5), 0, 1, 60, 65);
    float open = map(open_cred, 0, 100, 1,1.5f);
    pos[i].set(cos(theta)*r+width*.5f, sin(theta)*r*open+width*.5f);
  }
  pushMatrix();
  noStroke();
  beginShape();
  translate(-30, 100, 2);
  fill(255,202,56);
  for(int i=0; i<pos.length+3; i++){
    int idx = i%pos.length;
    curveVertex(pos[idx].x, pos[idx].y);
  }
  endShape();
  popMatrix();
}

//Fear mouth
 public void fear_mouth(float open_cred){
  for(int i=0; i<pos.length; i++){
    radiusF[i] += radiusFIncre[i];
    float theta = map(i, 0, pos.length, 0, TWO_PI);
    float r = map(noise(radiusF[i]*5), 0, 1, 60, 65);
    float open = map(open_cred, 0, 100, 1,1.5f);
    pos[i].set(cos(theta)*r+width*.5f, sin(theta)*r*open+width*.5f);
  }
  pushMatrix();
  noStroke();
  beginShape();
  translate(-30, 100, 2);
  fill(89,5,95);
  for(int i=0; i<pos.length+3; i++){
    int idx = i%pos.length;
    curveVertex(pos[idx].x, pos[idx].y);
  }
  endShape();
  popMatrix();
}
class Particle {
  PVector position;
  PVector velocity;
  PVector acceleration;
  float lifespan;

  Particle(PVector l) {
    acceleration = new PVector(0, 0.05f);
    velocity = new PVector(random(-.5f, .5f), random(-2, 0));
    position = l.copy();
    lifespan = 255.0f;
  }

   public void run() {
    update();
    display();
  }

   public void update() {
    velocity.add(acceleration);
    position.add(velocity);
    lifespan -= 1.0f;
  }

   public void display() {
    stroke(255, lifespan);
    fill(color(139,223,255), lifespan);
    ellipse(position.x, position.y, 15, 15);
  }

   public boolean isDead() {
    if (lifespan < 0.0f) {
      return true;
    } else {
      return false;
    }
  }
}

// A class to describe a group of Particles
// An ArrayList is used to manage the list of Particles 

class ParticleSystem {
  ArrayList<Particle> particles;
  PVector origin;

  ParticleSystem(PVector position) {
    origin = position.copy();
    particles = new ArrayList<Particle>();
  }

   public void addParticle() {
    particles.add(new Particle(origin));
  }

   public void run() {
    for (int i = particles.size()-1; i >= 0; i--) {
      Particle p = particles.get(i);
      p.run();
      if (p.isDead()) {
        particles.remove(i);
      }
    }
  }
}


class Particle2 {
  PVector position2;
  PVector velocity2;
  PVector acceleration2;
  float lifespan2;

  Particle2(PVector l) {
    acceleration2 = new PVector(0, 0.05f);
    velocity2 = new PVector(random(-.5f, .5f), random(-2, 0));
    position2 = l.copy();
    lifespan2 = 255.0f;
  }

   public void run2() {
    update2();
    display2();
  }

  // Method to update position
   public void update2() {
    velocity2.add(acceleration2);
    position2.add(velocity2);
    lifespan2 -= 1.0f;
  }

  // Method to display
   public void display2() {
    stroke(255, lifespan2);
    fill(color(139,223,255), lifespan2);
    ellipse(position2.x, position2.y, 15, 15);
  }

  // Is the particle still useful?
   public boolean isDead2() {
    if (lifespan2 < 0.0f) {
      return true;
    } else {
      return false;
    }
  }
}

class ParticleSystem2 {
  ArrayList<Particle2> particles2;
  PVector origin2;

  ParticleSystem2(PVector position2) {
    origin2 = position2.copy();
    particles2 = new ArrayList<Particle2>();
  }

   public void addParticle2() {
    particles2.add(new Particle2(origin2));
  }

   public void run2() {
    for (int i = particles2.size()-1; i >= 0; i--) {
      Particle2 p = particles2.get(i);
      p.run2();
      if (p.isDead2()) {
        particles2.remove(i);
      }
    }
  }
}


  public void settings() { size(800, 800);
smooth(8); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "Emotion_eye" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
